<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>requests库的学习 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="request库通俗理解# 1.request库的作用requests库就像是一个能干的 “跑腿助手”。在现实生活中，如果你要去商店拿东西，可能会亲自走过去，但在网络世界里，有很多复杂的步骤和规则，而requests库就帮你处理这些复杂的事情，让你可以轻松地从网络上获取信息。 *2. GET 请求的含义*GET 请求就相当于你跟商店店员说 “我想要某个东西”。在网络里，这个 “东西” 就是网页、图">
<meta property="og:type" content="article">
<meta property="og:title" content="requests库的学习">
<meta property="og:url" content="http://example.com/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="request库通俗理解# 1.request库的作用requests库就像是一个能干的 “跑腿助手”。在现实生活中，如果你要去商店拿东西，可能会亲自走过去，但在网络世界里，有很多复杂的步骤和规则，而requests库就帮你处理这些复杂的事情，让你可以轻松地从网络上获取信息。 *2. GET 请求的含义*GET 请求就相当于你跟商店店员说 “我想要某个东西”。在网络里，这个 “东西” 就是网页、图">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20250421210254912.png">
<meta property="og:image" content="http://example.com/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20250421210326218.png">
<meta property="og:image" content="http://example.com/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20250421212624763.png">
<meta property="og:image" content="http://example.com/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20250421213113557.png">
<meta property="og:image" content="http://example.com/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20250421213126517.png">
<meta property="og:image" content="http://example.com/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20250421214027917.png">
<meta property="article:published_time" content="2025-04-21T12:13:41.000Z">
<meta property="article:modified_time" content="2025-04-21T13:44:31.424Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20250421210254912.png">
  
    <link rel="alternate" href="../../../../atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="../../../../favicon.png">
  
  
  
<link rel="stylesheet" href="../../../../css/style.css">

  
    
<link rel="stylesheet" href="../../../../fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="../../../../index.html" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="../../../../index.html">Home</a>
        
          <a class="main-nav-link" href="../../../../archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="../../../../atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-requests库的学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="" class="article-date">
  <time class="dt-published" datetime="2025-04-21T12:13:41.000Z" itemprop="datePublished">2025-04-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      requests库的学习
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="request库通俗理解"><a href="#request库通俗理解" class="headerlink" title="request库通俗理解"></a>request库通俗理解</h3><h4 id="1-request库的作用"><a href="#1-request库的作用" class="headerlink" title="# 1.request库的作用"></a># 1.request库的作用</h4><p>requests库就像是一个能干的 “跑腿助手”。在现实生活中，如果你要去商店拿东西，可能会亲自走过去，但在网络世界里，有很多复杂的步骤和规则，而requests库就帮你处理这些复杂的事情，让你可以轻松地从网络上获取信息。</p>
<h4 id="2-GET-请求的含义"><a href="#2-GET-请求的含义" class="headerlink" title="*2. GET 请求的含义*"></a><em><strong>*2. GET 请求的含义*</strong></em></h4><p>GET 请求就相当于你跟商店店员说 “我想要某个东西”。在网络里，这个 “东西” 就是网页、图片、数据等资源。当你使用requests.get()方法并提供一个网址（比如<a target="_blank" rel="noopener" href="https://www.baidu.com)时,就好像你告诉店员/">https://www.baidu.com）时，就好像你告诉店员</a> “我要这家店（对应网址的服务器）的东西”。</p>
<h4 id="3-发送请求和获取响应"><a href="#3-发送请求和获取响应" class="headerlink" title="*3. 发送请求和获取响应*"></a><em><strong>*3. 发送请求和获取响应*</strong></em></h4><p>当你执行r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://www.baidu.com')这行代码时,就相当于你让/">https://www.baidu.com&#39;)这行代码时，就相当于你让</a> “跑腿助手”（requests库）去对应的 “商店”（服务器），并说出你想要的东西（发送 GET 请求）。然后 “跑腿助手” 会去那家 “商店”，把商店给的东西带回来。这个带回来的 “东西” 就存放在变量r里，它包含了服务器给你的各种信息，比如商品是不是成功拿到了（状态码）、商品具体是什么样子（响应内容）等。</p>
<h4 id="4-后续处理"><a href="#4-后续处理" class="headerlink" title="*4. 后续处理*"></a><em><strong>*4. 后续处理*</strong></em></h4><p>拿到 “东西” 后，你就可以看看这个 “东西” 怎么样。在代码里，你可以通过r.status_code查看请求是否成功（就像看看店员是不是把你要的东西给你了），通过r.text查看具体的内容（就像看看拿到的东西长啥样）。</p>
<p> 举个例子，假如你想要看某个新闻网站上的新闻，你就可以让requests这个 “跑腿助手” 去对应的新闻网站 “商店”，把新闻页面 “拿” 回来，然后你就能在自己的程序里查看这些新闻内容了。</p>
<p>用get请求去访问一个网站</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入requests库</span></span><br><span class="line">import requests</span><br><span class="line"><span class="comment">#发送一个get请求并得到响应</span></span><br><span class="line">r = requests.<span class="title function_ invoke__">get</span>(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="comment">#查看响应对象的类型</span></span><br><span class="line"><span class="keyword">print</span>(<span class="title function_ invoke__">type</span>(r))</span><br><span class="line"><span class="comment">#查看响应状态码</span></span><br><span class="line"><span class="keyword">print</span>(r.status_code)</span><br><span class="line"><span class="comment">#查看响应内容的类型</span></span><br><span class="line"><span class="keyword">print</span>(<span class="title function_ invoke__">type</span>(r.text))</span><br><span class="line"><span class="comment">#查看响应的内容</span></span><br><span class="line"><span class="keyword">print</span>(r.text)</span><br><span class="line"><span class="comment">#查看cookies</span></span><br><span class="line"><span class="keyword">print</span>(r.cookies)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果要添加请求参数，比如添加两个请求参数，其中name值是germey，age值是20</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">data = &#123;</span><br><span class="line">	<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;germey&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;age&#x27;</span>:<span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>,params=data)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">params=data` 是将之前定义的 `data` 字典作为查询参数添加到请求的 URL 中。也就是说，最终发送的请求 URL 会变成 `http://httpbin.org/get?name=germey&amp;age=22</span><br></pre></td></tr></table></figure>



<h3 id="user-agent"><a href="#user-agent" class="headerlink" title="user-agent"></a>user-agent</h3><h4 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h4><p><code>User-Agent</code> 字符串通常由多个部分组成，不同类型的客户端其格式会有所差异，但大致包含以下几类信息：</p>
<ul>
<li><strong>浏览器信息</strong>：如浏览器名称和版本号。例如 <code>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36</code> ，这里表明浏览器是 Chrome 114 版本。</li>
<li><strong>操作系统信息</strong>：显示客户端使用的操作系统及其版本。上述示例中的 <code>Windows NT 10.0</code> 就表示使用的是 Windows 10 操作系统。</li>
<li><strong>渲染引擎信息</strong>：像 <code>AppleWebKit/537.36</code> 体现了使用的是 WebKit 渲染引擎及其版本。</li>
</ul>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><h4 id="1-服务器适配"><a href="#1-服务器适配" class="headerlink" title="1. 服务器适配"></a>1. 服务器适配</h4><p>服务器可以根据 <code>User-Agent</code> 判断客户端类型，然后返回适合该客户端的内容。比如，对于手机浏览器，服务器可以返回移动端适配的页面，提供更好的浏览体验；对于搜索引擎爬虫，服务器可以返回适合被索引的内容。</p>
<h4 id="2-统计分析"><a href="#2-统计分析" class="headerlink" title="2. 统计分析"></a>2. 统计分析</h4><p>网站管理员可以通过分析 <code>User-Agent</code> 数据，了解访问者使用的设备和浏览器情况，为网站的优化和推广提供数据支持。例如，如果发现大部分用户使用的是某一款特定浏览器，就可以针对该浏览器进行重点测试和优化。</p>
<h4 id="3-反爬虫和安全防护"><a href="#3-反爬虫和安全防护" class="headerlink" title="3. 反爬虫和安全防护"></a>3. 反爬虫和安全防护</h4><p>部分网站会依据 <code>User-Agent</code> 来识别是否为正常的浏览器访问。如果 <code>User-Agent</code> 显示为明显的爬虫程序，网站可能会采取限制访问、封禁 IP 等措施。同时，异常的 <code>User-Agent</code> 也可能被视为潜在的安全威胁。</p>
<p>可以用request库 改user-agent 让服务器误认为是正常的浏览器访问</p>
<h3 id="常见的请求头信息"><a href="#常见的请求头信息" class="headerlink" title="常见的请求头信息"></a>常见的请求头信息</h3><ul>
<li><strong>Content-Type</strong>：指示返回内容的类型，例如 <code>text/html</code> 表示返回的是 HTML 文档。</li>
<li><strong>Content-Length</strong>：表示响应内容的长度（以字节为单位）。</li>
<li><strong>Server</strong>：标识服务器的类型和版本，如 <code>Apache</code> 或 <code>nginx</code> 等。</li>
<li><strong>Date</strong>：服务器生成响应的日期和时间。</li>
<li><strong>Connection</strong>：表示连接状态，如 <code>keep - alive</code> 表示连接将被保持，以便后续请求复用。</li>
</ul>
<h3 id="用requests库爬取二进制数据"><a href="#用requests库爬取二进制数据" class="headerlink" title="用requests库爬取二进制数据"></a>用requests库爬取二进制数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#向资源URL发送一个GET请求</span></span><br><span class="line">r = requests.get(<span class="string">&#x27;https://www.baidu.com/favicon.ico&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;favicon.ico&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(r.content)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&#39;https://www.baidu.com/favicon.ico&#39;</code> 是请求的目标 URL，<code>favicon.ico</code> 通常是网站的图标文件，用于在浏览器的标签页、书签栏等位置显示网站的标志。</p>
</li>
<li><p>这行代码会向百度服务器发送一个 GET 请求，请求获取百度的图标文件，并将服务器返回的响应对象赋值给变量 <code>r</code>。</p>
</li>
<li><p><code>open()</code> 是 Python 内置的用于打开文件的函数。</p>
</li>
<li><p><code>&#39;favicon.ico&#39;</code> 是要保存的文件名，即把下载的图标文件保存为本地的 <code>favicon.ico</code> 文件。</p>
</li>
<li><p><code>&#39;wb&#39;</code> 是文件打开模式，其中 <code>w</code> 表示写入模式，<code>b</code> 表示以二进制模式打开文件。因为图标文件是二进制文件，所以需要以二进制模式进行写入。</p>
</li>
<li><p><code>with</code> 语句用于创建一个上下文管理器，它会自动处理文件的打开和关闭操作，确保在代码块执行完毕后文件被正确关闭，避免资源泄漏。</p>
</li>
<li><p><code>as f</code> 把 <code>open(&#39;favicon.ico&#39;, &#39;wb&#39;)</code> 返回的文件对象赋值给变量 <code>f</code>。之后在 <code>with</code> 语句块里，你就可以使用 <code>f</code> 来调用文件对象的方法，比如 <code>f.write()</code> 用于向文件写入数据</p>
</li>
<li><p><code>r.content</code> 是响应对象 <code>r</code> 的一个属性，它返回服务器响应内容的字节形式。</p>
</li>
<li><p><code>f.write()</code> 是文件对象 <code>f</code> 的方法，用于将字节数据写入文件。这行代码将下载的图标文件的字节数据写入到本地的 <code>favicon.ico</code> 文件中。</p>
</li>
</ul>
<p>这段代码通过 <code>requests</code> 库发送 GET 请求从百度网站下载其图标文件，并使用 Python 的文件操作将图标文件保存为本地的 <code>favicon.ico</code> 文件。执行这段代码后，在当前工作目录下会生成一个名为 <code>favicon.ico</code> 的文件，该文件即为百度的图标</p>
<h3 id="用requests库实现文件上传"><a href="#用requests库实现文件上传" class="headerlink" title="用requests库实现文件上传"></a>用requests库实现文件上传</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#以二进制方式读取当前目录下的favicon.ico文件，并将其赋给file</span></span><br><span class="line">files = &#123;<span class="string">&#x27;file&#x27;</span>:<span class="built_in">open</span>(<span class="string">&#x27;favicon.ico&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)&#125;</span><br><span class="line"><span class="comment">#进行上传</span></span><br><span class="line">r = requests.post(<span class="string">&#x27;http://httpbin.org/post&#x27;</span>,files=files)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="处理Cookie"><a href="#处理Cookie" class="headerlink" title="处理Cookie"></a>处理Cookie</h3><img src="/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20250421210254912.png" class title="image-20250421210254912">

<img src="/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20250421210326218.png" class title="image-20250421210326218">

<h3 id="会话维持"><a href="#会话维持" class="headerlink" title="会话维持"></a>会话维持</h3><img src="/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20250421212624763.png" class title="image-20250421212624763">

<h4 id="s-requests-Session"><a href="#s-requests-Session" class="headerlink" title="s = requests.Session()"></a><code>s = requests.Session()</code></h4><p>调用 <code>requests.Session()</code> 函数创建一个会话对象 <code>s</code>。会话对象能在多次请求间保持状态，像 Cookie 信息、连接等，让后续的请求可以复用之前建立的连接，并且自动处理 Cookie 的存储和发送。</p>
<h4 id="s-get-http-httpbin-org-cookies-set-number-123456789"><a href="#s-get-http-httpbin-org-cookies-set-number-123456789" class="headerlink" title="s.get(&#39;http://httpbin.org/cookies/set/number/123456789&#39;)"></a><code>s.get(&#39;http://httpbin.org/cookies/set/number/123456789&#39;)</code></h4><ul>
<li>使用会话对象 <code>s</code> 的 <code>get</code> 方法发送一个 GET 请求到 <code>http://httpbin.org/cookies/set/number/123456789</code>。</li>
<li><code>httpbin.org</code> 是一个专门用于测试 HTTP 请求和响应的网站，<code>/cookies/set/number/123456789</code> 这个接口的作用是设置一个名为 <code>number</code>、值为 <code>123456789</code> 的 Cookie。由于使用的是会话对象，这个 Cookie 会被自动保存到会话中。</li>
</ul>
<h4 id="r-s-get-http-httpbin-org-cookies"><a href="#r-s-get-http-httpbin-org-cookies" class="headerlink" title="r = s.get(&#39;http://httpbin.org/cookies&#39;)"></a><code>r = s.get(&#39;http://httpbin.org/cookies&#39;)</code></h4><ul>
<li>再次使用会话对象 <code>s</code> 的 <code>get</code> 方法发送一个 GET 请求到 <code>http://httpbin.org/cookies</code>。</li>
<li><code>/cookies</code> 接口的功能是返回当前会话中的所有 Cookie 信息。服务器的响应会被存储在响应对象 <code>r</code> 中</li>
</ul>
<h3 id="SSL证书验证"><a href="#SSL证书验证" class="headerlink" title="SSL证书验证"></a>SSL证书验证</h3><img src="/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20250421213113557.png" class title="image-20250421213113557">

<img src="/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20250421213126517.png" class title="image-20250421213126517">

<p>代理设置<br>对于某些网站，在测试的时候请求几次，能正常获取内容。但是一旦开始大规模、频繁地爬取，网站可能会弹出验证码，或者跳转到登录验证页面，更有甚者可能会直接封禁客户端的IP，导致一定时间内无法访问。为了防止这种情况，我们需要使用代理来解决这个问题，这就需要用到proxies                  </p>
<p>1)设置代理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxies = &#123;</span><br><span class="line">  	<span class="comment">#该代理服务器在免费代理网站上得到的，这样的网站有很多</span></span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://161.35.4.201:80&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;https://161.35.4.201:80&#x27;</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = requests.get(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>, proxies=proxies)</span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br><span class="line"><span class="keyword">except</span> requests.exceptions.ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error&#x27;</span>, e.args)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>proxies</code> 是一个字典，其键值对指定了不同协议（<code>http</code> 和 <code>https</code>）对应的代理服务器地址。</p>
</li>
<li><p><code>&#39;http&#39;: &#39;http://161.35.4.201:80&#39;</code> 表明当发送 HTTP 请求时，会使用 <code>161.35.4.201</code> 这个 IP 地址、端口号为 <code>80</code> 的代理服务器。</p>
</li>
<li><p><code>&#39;https&#39;: &#39;https://161.35.4.201:80&#39;</code> 意味着发送 HTTPS 请求时，同样会使用该代理服务器。</p>
</li>
<li><p><code>try</code> 块</p>
<p>：</p>
<ul>
<li><code>requests.get(&#39;http://httpbin.org/get&#39;, proxies=proxies)</code>：调用 <code>requests</code> 库的 <code>get</code> 方法发送一个 GET 请求到 <code>http://httpbin.org/get</code>，并通过 <code>proxies</code> 参数指定使用之前定义的代理服务器。</li>
<li><code>print(response.text)</code>：若请求成功，将服务器返回的响应内容以字符串形式打印出来。<code>httpbin.org</code> 的 <code>/get</code> 接口会返回包含请求信息（如请求头、请求参数等）的 JSON 数据。</li>
</ul>
</li>
<li><p><code>except</code> 块</p>
<p>：</p>
<ul>
<li><code>except requests.exceptions.ConnectionError as e</code>：捕获可能出现的连接错误异常。当无法连接到代理服务器或者目标服务器时，会抛出 <code>ConnectionError</code> 异常。</li>
<li><code>print(&#39;Error&#39;, e.args)</code>：若捕获到异常，打印错误信息，<code>e.args</code> 包含了异常的详细参数</li>
</ul>
</li>
</ul>
<p>超时设置<br>在本机网络状况不好或者服务器网络响应太慢甚至无响应时，我们可能会等待特别久的时间才可能收到响应，甚至到最后收不到响应而报错。为了应对这种情况，应设置一个超时时间，这个时间是计算机发出请求到服务器返回响应的时间，如果请求超过了这个超时时间还没有得到响应，就抛出错误。这就需要使用timeout参数实现，单位为秒</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）指定请求总的超时时间</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#向淘宝发出请求，如果1秒内没有得到响应，则抛出错误</span></span><br><span class="line">r = requests.get(<span class="string">&#x27;https://www.taobao.com&#x27;</span>,timeout=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(r.status_code)</span><br></pre></td></tr></table></figure>

<p>2）分别指定超时时间。实际上，请求分为两个阶段：连接（connect）和读取（read）。如果给timeout参数指定一个整数值，则超时时 间是这两个阶段的总和；如果要分别指定，就可以传入一个元组，连接超时时间和读取超时时间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#向淘宝发出请求，如果连接阶段5秒内没有得到响应或读取阶段30秒内没有得到响应，则抛出错误</span></span><br><span class="line">r = requests.get(<span class="string">&#x27;https://www.taobao.com&#x27;</span>,timeout=(<span class="number">5</span>,<span class="number">30</span>))</span><br><span class="line"><span class="built_in">print</span>(r.status_code)</span><br></pre></td></tr></table></figure>

<p>3）如果想永久等待，可以直接timeout设置为None，或者不设置timeout参数，因为它的默认值就是None。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#向淘宝发出请求，如果连接阶段5秒内没有得到响应或读取阶段30秒内没有得到响应，则抛出错误</span></span><br><span class="line">r = requests.get(<span class="string">&#x27;https://www.taobao.com&#x27;</span>,timeout=<span class="literal">None</span>))</span><br><span class="line"><span class="built_in">print</span>(r.status_code)</span><br></pre></td></tr></table></figure>

<h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><img src="/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20250421214027917.png" class title="image-20250421214027917">

<p>1）此时可以使用requests自带的身份验证功能，通过HTTPBasicAuth类实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line">r = requests.get(<span class="string">&#x27;http://localhost:8080/manager/html&#x27;</span>,auth=HTTPBasicAuth(<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(r.status_code)</span><br></pre></td></tr></table></figure>

<p> 如果用户名和密码正确的话，返回200状态码；如果不正确，则返回401状态码。也可以不使用HTTPBasicAuth类，而是直接传入一个 元组，它会默认使用HTTPBasicAuth这个类来验证</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line">r = requests.get(<span class="string">&#x27;http://localhost:8080/manager/html&#x27;</span>,auth=(<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(r.status_code)</span><br></pre></td></tr></table></figure>

<h2 id="Prepared-Request"><a href="#Prepared-Request" class="headerlink" title="Prepared Request"></a>Prepared Request</h2><p>在学习urllib库时，发送请求如果需要设置请求头，需要通过一个Request对象来表示。在requests库中，存在一个与之类似的类，称为Prepared Request。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> Request,Session</span><br><span class="line">url = <span class="string">&#x27;http://httpbin.org/post&#x27;</span></span><br><span class="line">data = &#123;</span><br><span class="line">	<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;germey&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">	<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">s = Session()</span><br><span class="line">req = Request(<span class="string">&#x27;POST&#x27;</span>,url,data=data,headers=headers)</span><br><span class="line">prepped = s.prepare_request(req)</span><br><span class="line">r = s.send(prepped)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure>

<h4 id="1-from-requests-import-Request-Session"><a href="#1-from-requests-import-Request-Session" class="headerlink" title="1. from requests import Request, Session"></a>1. <code>from requests import Request, Session</code></h4><p>从 <code>requests</code> 库中导入 <code>Request</code> 和 <code>Session</code> 类。<code>Request</code> 类用于构建 HTTP 请求对象，<code>Session</code> 类用于管理会话，它可以在多个请求之间保持状态，例如 Cookie 信息。</p>
<h4 id="2-url-http-httpbin-org-post"><a href="#2-url-http-httpbin-org-post" class="headerlink" title="2. url = &#39;http://httpbin.org/post&#39;"></a>2. <code>url = &#39;http://httpbin.org/post&#39;</code></h4><p>定义请求的目标 URL，即要发送 POST 请求的地址。</p>
<h4 id="3-data-name-germey"><a href="#3-data-name-germey" class="headerlink" title="3. data = {&#39;name&#39;: &#39;germey&#39;}"></a>3. <code>data = &#123;&#39;name&#39;: &#39;germey&#39;&#125;</code></h4><p>定义一个字典 <code>data</code>，其中包含要随请求发送的数据。在这个例子中，数据是一个键值对 <code>&#123;&#39;name&#39;: &#39;germey&#39;&#125;</code>，表示要发送的参数 <code>name</code> 的值为 <code>germey</code>。</p>
<h4 id="4-headers-User-Agent-Mozilla-5-0-Windows-NT-10-0-Win64-x64-rv-95-0-Gecko-20100101-Firefox-95-0"><a href="#4-headers-User-Agent-Mozilla-5-0-Windows-NT-10-0-Win64-x64-rv-95-0-Gecko-20100101-Firefox-95-0" class="headerlink" title="4. headers = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0&#39;}"></a>4. <code>headers = &#123;&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0&#39;&#125;</code></h4><p>定义一个字典 <code>headers</code>，其中包含要随请求发送的请求头信息。<code>User-Agent</code> 是一个常见的请求头字段，用于标识客户端的类型和版本信息。这里模拟了 Firefox 浏览器的用户代理信息，让服务器认为请求是由 Firefox 浏览器发出的。</p>
<h4 id="5-s-Session"><a href="#5-s-Session" class="headerlink" title="5. s = Session()"></a>5. <code>s = Session()</code></h4><p>创建一个 <code>Session</code> 对象 <code>s</code>，用于管理会话。通过会话对象发送请求可以自动处理 Cookie 等状态信息。</p>
<h4 id="6-req-Request-POST-url-data-data-headers-headers"><a href="#6-req-Request-POST-url-data-data-headers-headers" class="headerlink" title="6. req = Request(&#39;POST&#39;, url, data=data, headers=headers)"></a>6. <code>req = Request(&#39;POST&#39;, url, data=data, headers=headers)</code></h4><p>创建一个 <code>Request</code> 对象 <code>req</code>，用于构建 HTTP 请求。</p>
<ul>
<li><code>&#39;POST&#39;</code> 表示请求的方法为 POST。</li>
<li><code>url</code> 是请求的目标 URL。</li>
<li><code>data=data</code> 表示将之前定义的 <code>data</code> 字典作为请求的数据发送。</li>
<li><code>headers=headers</code> 表示将之前定义的 <code>headers</code> 字典作为请求头信息发送。</li>
</ul>
<h4 id="7-prepped-s-prepare-request-req"><a href="#7-prepped-s-prepare-request-req" class="headerlink" title="7. prepped = s.prepare_request(req)"></a>7. <code>prepped = s.prepare_request(req)</code></h4><p>调用 <code>Session</code> 对象的 <code>prepare_request</code> 方法，将 <code>Request</code> 对象 <code>req</code> 准备为一个可以发送的请求对象 <code>prepped</code>。这个步骤会对请求进行一些预处理，例如设置默认的请求头、处理编码等。</p>
<h4 id="8-r-s-send-prepped"><a href="#8-r-s-send-prepped" class="headerlink" title="8. r = s.send(prepped)"></a>8. <code>r = s.send(prepped)</code></h4><p>调用 <code>Session</code> 对象的 <code>send</code> 方法，发送准备好的请求对象 <code>prepped</code>，并将服务器返回的响应对象赋值给变量 <code>r</code>。</p>
<h4 id="9-print-r-text"><a href="#9-print-r-text" class="headerlink" title="9. print(r.text)"></a>9. <code>print(r.text)</code></h4><p>打印服务器返回的响应内容，<code>r.text</code> 是响应对象 <code>r</code> 的一个属性，它返回服务器返回的响应内容，以字符串形式呈现。</p>
<p>这里引入了Request，然后用url、data和headers参数构造了一个Request对象，这时需要再调用Session的prepare_request( )方法将其转换为一个Prepared Request对象，然后调用send( )方法发送。这样做的好处时：可以利用Request将请求当作独立的对象来看待，这样在进行队列调度时会非常方便，后面会用它来构造一个Request队列<br>这段代码通过 <code>Request</code> 和 <code>Session</code> 类手动构建并发送了一个 HTTP POST 请求，展示了如何使用 <code>requests</code> 库的高级功能来精细控制请求的构建和发送过程。与直接使用 <code>requests.post()</code> 方法相比，这种方式可以更灵活地处理请求和会话状态。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_43404934/article/details/122331463">https://blog.csdn.net/m0_43404934/article/details/122331463</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/" data-id="cm9z667v1000enouo049z0md2" data-title="requests库的学习" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="../../23/phptexing/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          phptexing
        
      </div>
    </a>
  
  
    <a href="../../13/ctfshow29-52/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">ctfshow29-52</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2025/04/">April 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="../../27/222/">222</a>
          </li>
        
          <li>
            <a href="../../27/111/">111</a>
          </li>
        
          <li>
            <a href="../../27/1234/">1234</a>
          </li>
        
          <li>
            <a href="../../25/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/">文件上传</a>
          </li>
        
          <li>
            <a href="../../25/%E6%97%A0%E6%95%B0%E5%AD%97%E5%AD%97%E6%AF%8Drce/">无数字字母rce</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="../../../../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../../../../archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="../../../../js/jquery-3.6.4.min.js"></script>



  
<script src="../../../../fancybox/jquery.fancybox.min.js"></script>




<script src="../../../../js/script.js"></script>





  </div>
</body>
</html>